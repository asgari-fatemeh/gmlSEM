<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.0.36">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>mlgSEM</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
div.csl-bib-body { }
div.csl-entry {
  clear: both;
}
.hanging div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}
</style>


<script src="Syntax_files/libs/clipboard/clipboard.min.js"></script>
<script src="Syntax_files/libs/quarto-html/quarto.js"></script>
<script src="Syntax_files/libs/quarto-html/popper.min.js"></script>
<script src="Syntax_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="Syntax_files/libs/quarto-html/anchor.min.js"></script>
<link href="Syntax_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="Syntax_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="Syntax_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="Syntax_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="Syntax_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">mlgSEM</h1>
</div>



<div class="quarto-title-meta">

    
    
  </div>
  

</header>

<section id="multi-level-genelaralized-sem-in-r" class="level2">
<h2 class="anchored" data-anchor-id="multi-level-genelaralized-sem-in-r">Multi-Level Genelaralized SEM in R</h2>
<p>This project aims at developing Generalized Multi-Level SEM in R. The main motivation was to develop SEM models for zero-inflated and zero-one-inflated beta responses (i.e.&nbsp;respones that take values on either [0,1], [0,1) or (0,1] intervals). The approach is based on maximum likelihood estimation and is in the line of the works of <span class="citation" data-cites="muthen2002beyond">Muthén (<a href="#ref-muthen2002beyond" role="doc-biblioref">2002</a>)</span> and <span class="citation" data-cites="rabe2004generalized">Rabe-Hesketh, Skrondal, and Pickles (<a href="#ref-rabe2004generalized" role="doc-biblioref">2004</a>)</span>. Since introducing other distributions and families and their zero (or <em>d</em>)-inflated versions are straightforward and a complete framework for Generalized SEM in the <strong>#rstat</strong> is absent, we have implemented the codes to support other distributions. In the case of the exponential family of distributions <em>mlgSEM</em> supports models which can be run in <em>gsem</em> at <em>stata</em> software. Additionally in confronting outlier data in our main motivation problem, we take advantage of Trimmed Likelihood (TL) Estimators as in <span class="citation" data-cites="muller2003breakdown">Müller and Neykov (<a href="#ref-muller2003breakdown" role="doc-biblioref">2003</a>)</span> and developed an algorithm to employ TL Estimators in multi-level settings which is available in the package.</p>
<p><em>mlgSEM</em> uses a text-based interface to define the models. It uses a similar syntax to lavaan (<span class="citation" data-cites="rosseel2012lavaan">Rosseel (<a href="#ref-rosseel2012lavaan" role="doc-biblioref">2012</a>)</span>) and indeed we used some parts of the codes like the parser from <em>lavaan</em> and extended the language. Thus a user familiar with <em>lavaan</em> syntax can start developing the codes by learning the extended syntax.</p>
<p>The extended syntax helps to:</p>
<ul>
<li><p>define levels (or clusters) in the data,</p></li>
<li><p>introduce (named) random terms in the model,</p></li>
<li><p>set the desired distributions for reponse models</p></li>
</ul>
</section>
<section id="extended-syntax" class="level2">
<h2 class="anchored" data-anchor-id="extended-syntax">Extended Syntax</h2>
<p>Basically, the <em>mlgSEM</em> syntax for defining Multi-Level Generalized SEM is an extended version of <em>lavaan</em> syntax (<span class="citation" data-cites="rosseel2012lavaan">Rosseel (<a href="#ref-rosseel2012lavaan" role="doc-biblioref">2012</a>)</span>). So if you not familiar with lavaan syntax, read the <a href="https://lavaan.ugent.be/tutorial/tutorial.pdf">lavaan manual</a> first and continue reading the <em>mlgSEM</em> extended syntax. Starting with the <em>lavaan</em> syntax, you have anything you used to have with <em>lavaan</em> syntax, except in the way that we define level blocks and the fact that you can use both <code>,</code> and <code>+</code> interchangeably in a measurement model block or in the left hand side of a regression model. In <em>mlgSEM</em> both <code>eta=~y1,y2,y3</code> and <code>eta=~y1+y2+y3</code> are identical.</p>
<p>In a glimpse the extended <em>mlgSEM</em> syntax helps you to define hierarchy structure of data using <code>level:</code> command for Multi-Level SEM. You can use <code>family:</code> command to define the family of distribution of response variables and also use copula functions to imply conditional dependency in a set of response variables varying at the same level. You can define random terms in the regression blocks and reuse them as response or covariate terms in other regression blocks. Using <em>mlgSEM</em> syntax you can also fit semi-parameteric regression models by using <code>s()</code> terms in the regression block which add smooth terms to the regression model, like <code>y=s(x)</code>. See <code>?mlgSEM::s</code> to learn more. Additionally <em>mlgSEM</em> syntax encompasses other features such as <em>ellipsis</em> and <em>alias</em>, so you can more easily work around the codes to develop your <em>mlgSEM</em> models. Though in <em>mlgSEM</em>, <em>ellipsis</em> is not a necessary part, it helps alot to achieve a concise presentation of the model. Hence we start with introducing this easy feature and other easy parts, and then will continue with the level block, family block.</p>
<p>During this tutorial, we use <code>mlgSEM::AttitudeDataset</code>. It is a simulated data in which the attitude of students is recorded in variables a1,…,a5 and the performance of students in three major courses are recorded as p1,p2,p3. Subjects are clustered in classes within schools, and the school id and class id for each subject are specified in variables <em>school</em> and <em>class</em>.</p>
<section id="ellipsis" class="level3">
<h3 class="anchored" data-anchor-id="ellipsis">Ellipsis</h3>
<p>In <em>mlgSEM</em>, you can use ellipsis <code>…</code> to avoid writing a sequence of variables whenever it make sense. For example in <em>mlgSEM</em> syntax, <code>y1,…,y5</code> is a short version of y1,y2,y3,y4,y5 and <code>y1+…+y5</code> is a short version of y1+y2+y3+y4+y5. Also <code>y1a+…+y5a</code> is the short version of y1a+y2b+y3a+y4a+y5a, and <code>y1a,…,y1e</code> is a short version of y1a,y1b,y1c,y1d,y1e. In the <em>mlgSEM</em> code, <code>…</code> simply replace by the missed part of the sequence. The parser is moderately smart, and you can use ellipsis to concise any sequence that of which the template is easy to infer. If helps you can add the first two terms of the sequence to let the parser infer the sequence. For example <code>y11,y12,…,y112</code> is the short version of y11,y12,y13,y14,y15,y16,y17,y18,y19,y110,y111,y112, and <code>y1a,y2b,…,y5e</code> is the short version of y1a,y2b,y3c,y4d,y5e.</p>
<p>To insure that the parser understood you well, you can print the digested syntax with <code>syntax(model)</code>. In the case of using ellipsis in the model syntax, you can use the same convention to name the parameters,</p>
<div id="exm-ellipsis2" class="theorem example">
<p><span class="theorem-title"><strong>Example 1 (Labeling parameters using ellipsis) </strong></span></p>
<pre><code>model1&lt;-' at  =~ (lambda1,...,lambda5)*(a1,...,a5)'</code></pre>
</div>
<p>In <a href="#exm-ellipsis2">Example&nbsp;1</a> a latent variable is defined using five indicators a1,a2,a3,a4,a5 with corresponding factor loadings lambda1,lambda2,lambda3,lambda4,lambda5.</p>
</section>
<section id="alias" class="level3">
<h3 class="anchored" data-anchor-id="alias">Alias</h3>
<p>Aliases are convenient for defining short and long version of variable and parameter names to have a concise code and clear outputs. It happens that you want to use a short version of variable to have a more concise code, and you want to print the full name of a variable in the outputs. To do this you can define variable aliases with keyword <code>as</code> by the following syntax</p>
<pre><code>dp as depression</code></pre>
<p>Consequently you can use dp and depression interchangeably in the code, while by convenient the right hand side of <code>as</code> keyword is displayed in the outputs. Consequently, when defining aliases you are free to use any character including space on the right hand side of <code>as</code> keyword, however if you use special characters or strings such space, <code>,</code>, <code>+</code> or <code>=~</code> then you can not use the alias on the right hand side in the family, regression or measurement blocks. The same scenario also hold for parameter names. Variable and parameter aliases can also be defined in the <code>mlgSEM</code> function by passing an <em>alias</em> argument to the function:</p>
<pre><code>mlgsem&lt;-mlgSEM(...,alias=c("p"="depression"))</code></pre>
</section>
<section id="random-terms" class="level3">
<h3 class="anchored" data-anchor-id="random-terms">Random terms</h3>
<p>In mlgSEM you can use random terms in the regression models, as you do it in <code>lme4::lmer</code>. In the following example we use a random intercept to define a variance component factor model for attitude in mlgSEM::AttitideData.</p>
<div id="exm-exam01" class="theorem example">
<p><span class="theorem-title"><strong>Example 2 (Variance-component factor model) </strong></span></p>
<pre><code>library(mlgSEM)

model&lt;-'at as attitude

        at =~ a1,...,a5
        at = 0 + (1|class)'
          
mlgsem&lt;-mlgSEM(model,AttitudeData)</code></pre>
</div>
<div class="remark proof">
<p><span class="proof-title"><em>Remark</em>. </span>Intercept in regression models: You can explicitly include or exclude intercept in the regression models by adding one of the values -1|0|1 to the model. By default, in <em>mlgSEM</em> the regression models in which the response is a latent variable does not have an intercept while a regression model in which the response is an observed variable includes an intercept. Thus the ‘0’ in the regression model in previous example is redundant and is considered by default in <em>mlgSEM</em>.</p>
</div>
<p>You can use assigned names to the random terms to use it as a response or covariate term in other regression models. in <em>mlgSEM</em>, you can use the suffix assign operator <code>[as .]</code> to name any random term in the regression model as in the following example. Consider that you can use name specifier operator <code>[as .]</code> only after random terms in the regression models.</p>
<div id="exm-exam1" class="theorem example">
<p><span class="theorem-title"><strong>Example 3 (Variance-component factor model) </strong></span></p>
<pre><code>library(mlgSEM)

model&lt;-'at as attitude
        
        at =~ a1,...,a5
        at = 0 + (1[as c.t]|class)'
          
mlgsem&lt;-mlgSEM(model,AttitudeData)</code></pre>
</div>
<p>In the previous example we use the suffix operator <code>[as .]</code> to assign the name ‘c.t’ to the random intercept. If you do not assign name to the random terms, <em>mlgSEM</em> automatically assign names to the random terms by convention with the template response.level.covariate. For example in <code>at = 0 + (1 + x |class)</code>, the <em>mlgSEM</em> assign names <code>at.class.1</code> and <code>at.class.x</code> by convention to the random intercept and random slop terms, respectively.</p>
<p>As in <em>lavaan</em>, in measurement and regression models you can assign parameter labels to the parameters of the model using pre-multiplication mechanism (using <code>*</code> operator). In a regression model, pre-multiplication mechanism assign parameter labels to either regression coefficient or random term’s standard deviation, depending it is a fixed term or random term. Thus in the following example <code>beta</code> refers to the regression coefficient of the fixed term <code>x</code>, and <code>c.t.std</code> refers to the standard deviation of the random intercept term in the model.</p>
<div id="exm-exam1" class="theorem example">
<p><span class="theorem-title"><strong>Example 4 (Variance-component factor model) </strong></span></p>
<pre><code>library(mlgSEM)

model&lt;-'at as attitude
          
        at =~ a1,...,a5
        at = 0 + beta*x + (c.t.std*1[as c.t]|class)'
          
mlgsem&lt;-mlgSEM(model,AttitudeData)</code></pre>
</div>
</section>
<section id="level" class="level3">
<h3 class="anchored" data-anchor-id="level">Level</h3>
<p>In a Mult-Level SEM, for the data is assumed a hierarchy structure. The observed and latent variables vary at different levels. In <em>mlgSEM</em> you can use the <code>level:</code> block to specify the levels and nested levels and use the phrase <code>vary at level</code> or its variant <code>varies at level</code> to specify which latent or observed variable vary at which level if necessary. In a Multi-Level model at <em>mlgSEM</em>, we use ‘record’ and ‘elementary unit’ interchangeably to refer to the units at the lowest level. The data can be provided in <em>mlgSEM</em> with one or more data frame. When the <em>mlgSEM</em> is provided by a data frame, an elementary unit is simply a row in the data frame. When multiple data frames feed to <em>mlgSEM</em>, an elementary unit is a row in the data frame representing data at the lowest level.</p>
<p>Considering simulated dataset <code>mlgSEM::AttitudeData</code>. Students attitude is recorded in variables a1, …, a5 and the performance of students in three major courses are recorded as p1, p2, p3. Subjects are clustered in classes and schools, and the school id and class id for each subject are specified in variables <em>school</em> and <em>class</em>. In <em>mlgSEM</em>, to define a multi-level factor model, we can use one or more <code>level:</code> blocks to specify the levels,</p>
<div id="exm-lev1" class="theorem example">
<p><span class="theorem-title"><strong>Example 5 (Factor model with two levels) </strong></span></p>
<pre><code>level: school
s.a as school climate

s.a varies at level school

s.a =~ a1,...,a5</code></pre>
</div>
<p>In <a href="#exm-lev1">Example&nbsp;5</a> a factor model with two levels is defined. The first level is ‘base’ level encompasses elementary units, and the second level is defined by variable school with <code>level: school</code>. The latent variable s.a as ‘school climate’ is defined that varies at the second level.</p>
<p>The next model, defines three factor models in a three level model.</p>
<div id="exm-lev2" class="theorem example">
<p><span class="theorem-title"><strong>Example 6 (Factor model with three levels) </strong></span></p>
<pre><code>level: school
level: class within school

s.a as school climate
s.p as school performance
c.p as class performance

s.p,s.a vary at level school
c.p     varies at level class

s.a    =~ a1,...,a5
sp,c.p =~ p1,...,p5</code></pre>
</div>
<p>In <a href="#exm-lev2">Example&nbsp;6</a> the second level is class nested within school as the third level. Both 2<sup>nd</sup> and 3<sup>rd</sup> level and their nested structure is understood in the second line, and hence the first line is redundant. The model will remain unchanged if you omit the first line.</p>
<p>For models with higher number of levels, you can use multiple <code>within</code> keyword in a single <code>level:</code> command to specify the nested structure of the levels.</p>
<p>Combining random effects in SEM make the models more flexible and easy to write and interpret in some scenarios. To see an example, we will rewrite an equivalent form of the variance-component factor model in <a href="#exm-exam1">Example&nbsp;4</a> in terms of a two-level factor model. That is to define two latent variables with the same factor model, one varies at the base level and the other one varies at the level class named ‘class climate’, with a constraint that factor loadings are equal in both factor models.</p>
<div id="exm-exam2" class="theorem example">
<p><span class="theorem-title"><strong>Example 7 (Variance-component factor model-hard syntax) </strong></span></p>
<pre><code>model&lt;-'level: class
        at as attitude
        c.c as class climate
          
        c.c varies at level class
          
        at  =~ (lambda1,...,lambda5)*(a1,...,a5)
        c.c =~ (lambda1,...,lambda5)*(a1,...,a5)'</code></pre>
</div>
<p>In <a href="#exm-exam2">Example&nbsp;7</a> a level is defined and a latent variable ‘c.c’ as ‘class climate’ which varies at this level. Two latent factors ‘attitude’ and ‘class climate’ are defined with a constraint that factor loadings are equal in both factor model, while attitude varies at the ‘base’ level and ‘class climate’ varies at level ‘class’. The two factor models could also be combined into a single line as</p>
<pre><code>        c.c,at=~(lambda1,…,lambda5)*(a1,…,a5)</code></pre>
<div class="remark proof">
<p><span class="proof-title"><em>Remark</em>. </span>It is a good practice to use <code>vary at level</code> phrase and explicitly list all latent variables and observed response variables that vary at the second level or higher, though it is not always necessary. If the level at which an observed response variable or a latent variable varies is not specified in the model, <em>mlgSEM</em> will infer it from data and model. Concerning the observed response variables, <em>mlgSEM</em> will scan the variable and will identify the level at which the given variable varies, and concerning the latent variables, <em>mlgSEM</em> infers the level from the measurement models. There is no need to list the variables that varies at the ‘<em>base</em>’ level, however you can do it by</p>
<pre><code>var_y varies at level 1</code></pre>
<p>If the level is not specified for a latent variable, <em>mlgSEM</em> will produce a warning and will consider the lowest level at which all the indicator variables vary at that level or a lower sublevel.</p>
</div>
<div class="remark proof">
<p><span class="proof-title"><em>Remark</em>. </span>The order of lines in <em>mlgSEM</em> syntax does not matter. So <a href="#exm-exam2">Example&nbsp;7</a> can also be reordered to get easier to read as</p>
<pre><code>model&lt;-'level: class

        at as attitude
        at  =~ (lambda1,...,lambda5)*(a1,...,a5)
        
        c.c as class climate
        c.c varies at level class
        c.c =~ (lambda1,...,lambda5)*(a1,...,a5)'</code></pre>
</div>
</section>
<section id="family" class="level3">
<h3 class="anchored" data-anchor-id="family">Family</h3>
<p>In <em>mlgSEM</em> you can define the distribution of endogenous observe or latent variables either in a <code>family:</code> block, or in the regression or measurement block of the model. In the following examples model1 and model2 are identical and define a factor model with zero-inflated beta distribution for indicators. You can use many other distributions in <em>mlgSEM</em>. See <code>?mlgSEM::family</code> to learn more about different distributions that is provided in the package. You can also define your own distribution to use in <em>mlgSEM</em>.</p>
<div id="exm-fam1" class="theorem example">
<p><span class="theorem-title"><strong>Example 8 (Factor model with zero-inflated beta indicators) </strong></span></p>
<pre><code>model1&lt;-'family: y1,y2,...,y5 zoib(link=c("probit","logit"),type="[0,1]")
          eta =~ y1+...+y5'
         
model2&lt;-'eta =~ y1+...+y5, family=zoib(link=c("probit","logit"),type="[0,1]")'</code></pre>
</div>
<p>The advantage of introducing the distribution using the <code>family:</code> command is that we can use a copula function to induce the conditional dependency between endogenous observed or latent variables.</p>
<div id="exm-fam2" class="theorem example">
<p><span class="theorem-title"><strong>Example 9 (Using copula to induce conditional dependency in factor models) </strong></span></p>
<pre><code>model1&lt;-'family: y1,y2,...,y5 binomial(link="probit") copula(type="gaussian")
          eta =~ y1+...+y5'
          
model2&lt;-'family: y1,y2,...,y10 binomial(link="probit") copula(type="gaussian")
         family: eta1,eta2 gamma(lin="log") copula(type="gaussian")
         eta =~ y1+...+y5'</code></pre>
</div>
<p>Introducing a copula term in the <code>family:</code> comand lead to multivariate conditional dependency between the variables in that command provided that they varying in the same level. If the variables vary at different levels, each set of variables varying at the same level will consider to be conditionally dependent using the introduced copula. For example in the following model, the set of <code>y1,…,y5</code> are conditionally dependent according to the Gaussian copula at level class, and <code>y6,…,y10</code> are conditionally dependent according to the Gaussian copula at level school.</p>
<div id="exm-fam3" class="theorem example">
<p><span class="theorem-title"><strong>Example 10 (Using copula to induce conditional dependency in a multi-level factor model) </strong></span></p>
<pre><code>model&lt;-'level: class within school
         y1,...,y5 vary at level class
         y6,...,y10 vary at level school
         
         family: y1,y2,...,y10 binomial(link="probit") copula(type="gaussian")
         
         eta1 =~ y1+...+y5
         eta2 =~ y1+...+y5'</code></pre>
</div>
<p>In the <a href="#exm-fam3">Example&nbsp;11</a>, <em>eta1</em> is a latent variable vary at level <em>class</em>, and <em>eta2</em> is a latent variable vary at level <em>school</em>. Adding a <code>family:</code> command with copula for defining the family of distribution for these two variable producing a warning and mlgSEM simply ignore the copula structure:</p>
<div id="exm-fam3" class="theorem example">
<p><span class="theorem-title"><strong>Example 11 </strong></span></p>
<pre><code>model&lt;-'level: class within school
         y1,...,y5 vary between classes
         y6,...,y10 vary between schools
         
         family: y1,y2,...,y10 binomial(link="probit") copula(type="gaussian")
         family: eta1,eta2 gamma(link="log") copula(type="gaussian")
         
         eta1 =~ y1+...+y5
         eta2 =~ y1+...+y5'</code></pre>
</div>
<p>Defining the distribution family in the regression blocks is also possible, however it is not flexible as the <code>family:</code> command, for example we cannot use copula to introduce conditional dependencies between non-Gaussian variables, or to take advantage of <em>ellipsis</em> to define the distribution family of a set of variables in a single statement. Additionally, you can define the distribution of indicator variables only at a <code>family:</code> command.</p>
<div id="exm-fam5" class="theorem example">
<p><span class="theorem-title"><strong>Example 12 (A probit regression model) </strong></span></p>
<pre><code>model&lt;-'y = x1 + x2, family=binomial(link="probit")'</code></pre>
</div>

</section>
</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" role="doc-bibliography">
<div id="ref-muller2003breakdown" class="csl-entry" role="doc-biblioentry">
Müller, Christine H, and Neyko Neykov. 2003. <span>“Breakdown Points of Trimmed Likelihood Estimators and Related Estimators in Generalized Linear Models.”</span> <em>Journal of Statistical Planning and Inference</em> 116 (2): 503–19.
</div>
<div id="ref-muthen2002beyond" class="csl-entry" role="doc-biblioentry">
Muthén, Bengt O. 2002. <span>“Beyond SEM: General Latent Variable Modeling.”</span> <em>Behaviormetrika</em> 29 (1): 81–117.
</div>
<div id="ref-rabe2004generalized" class="csl-entry" role="doc-biblioentry">
Rabe-Hesketh, Sophia, Anders Skrondal, and Andrew Pickles. 2004. <span>“Generalized Multilevel Structural Equation Modeling.”</span> <em>Psychometrika</em> 69 (2): 167–90.
</div>
<div id="ref-rosseel2012lavaan" class="csl-entry" role="doc-biblioentry">
Rosseel, Yves. 2012. <span>“Lavaan: An r Package for Structural Equation Modeling.”</span> <em>Journal of Statistical Software</em> 48: 1–36.
</div>
</div></section></div></main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    setTimeout(function() {
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      let href = ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const cites = ref.parentNode.getAttribute('data-cites').split(' ');
    tippyHover(ref, function() {
      var popup = window.document.createElement('div');
      cites.forEach(function(cite) {
        var citeDiv = window.document.createElement('div');
        citeDiv.classList.add('hanging-indent');
        citeDiv.classList.add('csl-entry');
        var biblioDiv = window.document.getElementById('ref-' + cite);
        if (biblioDiv) {
          citeDiv.innerHTML = biblioDiv.innerHTML;
        }
        popup.appendChild(citeDiv);
      });
      return popup.innerHTML;
    });
  }
});
</script>
</div> <!-- /content -->



</body></html>
