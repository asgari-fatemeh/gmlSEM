---
title: "gmlSEM"
format: html
editor: visual
bibliography: refs.bib
---

## Genelaralized Multi-Level SEM in R

This project aims at developing Generalized Multi-Level SEM in R. The main motivation was to develop SEM models for zero-inflated and zero-one-inflated beta responses (i.e. respones that take values on either \[0,1\], \[0,1) or (0,1\] intervals). The approach is based on maximum likelihood estimation and is in the line of the works of @muthen2002beyond and @rabe2004generalized. Since introducing other distributions and families and their zero (or *d*)-inflated versions are straightforward and a complete framework for Generalized SEM in the **#rstat** is absent, we have implemented the codes to support other distributions. In the case of the exponential family of distributions *gmlSEM* supports models which can be run in *gsem* at *stata* software. Additionally in confronting outlier data in our main motivation problem, we take advantage of Trimmed Likelihood (TL) Estimators as in @muller2003breakdown and developed an algorithm to employ TL Estimators in multi-level settings which is available in the package.

*gmlSEM* uses a text-based interface to define the models. It uses a similar syntax to lavaan (@rosseel2012lavaan) and indeed we used some parts of the codes like the parser from *lavaan* and extended the language. Thus a user familiar with *lavaan* syntax can start developing the codes by learning the extended syntax.

The extended syntax helps to:

-   define levels (or clusters) in the data,

-   introduce (named) random terms in the model,

-   set the desired distributions for reponse models

## Extended Syntax

Basically, the *gmlSEM* syntax for defining Multi-Level Generalized SEM is an extended version of *lavaan* syntax (@rosseel2012lavaan). So if you are not familiar with lavaan syntax, read the [lavaan manual](https://lavaan.ugent.be/tutorial/tutorial.pdf) first and continue reading the *gmlSEM* extended syntax. Starting with the *lavaan* syntax, you have anything you used to have with *lavaan* syntax, except in the way that we define level blocks.

In a glimpse the extended *gmlSEM* syntax helps you to define hierarchy structure of data using `level:` command for Multi-Level SEM. You can use `family:` command to define the family of distribution of response variables and also use copula functions to imply conditional dependency in a set of response variables varying at the same level. You can define random terms in the regression blocks and reuse them as response or covariate terms in other regression blocks. Using *gmlSEM* syntax you can also fit semi-parameteric regression models by using `s()` terms in the regression block which add smooth terms to the regression model, like `y=s(x)`. See `?gmlSEM::s` to learn more. Additionally *gmlSEM* syntax encompasses other features such as *ellipsis* and *alias*, so you can more easily work around the codes to develop your *gmlSEM* models. Though in *gmlSEM*, *ellipsis* is not a necessary part, it helps alot to achieve a concise presentation of the model. Hence we start with introducing this easy feature and other easy parts, and then will continue with the *level* and *family* blocks.

During this tutorial, we use `gmlSEM::AttitudeDataset`. It is a simulated data in which the attitude of students is recorded in variables a1,...,a5 and the performance of students in three major courses are recorded as p1, p2, p3. Subjects are clustered in classes within schools, and the school id and class id for each subject are specified in variables *school* and *class*.

### Ellipsis

In *gmlSEM*, you can use ellipsis `...` to avoid writing a sequence of variables whenever it make sense. For example in *gmlSEM* syntax, `y1,...,y5` is a short version of y1,y2,y3,y4,y5 and `y1+...+y5` is a short version of y1+y2+y3+y4+y5. Also `y1a+...+y5a` is the short version of y1a+y2a+y3a+y4a+y5a, and `y1a,...,y1e` is a short version of y1a,y1b,y1c,y1d,y1e. In a *gmlSEM* model, `...` simply will be replaced by the missed part of the sequence. The parser is moderately smart, and you can use ellipsis to concise any sequence that of the template is easy to infer. If helps you can add the first two elements of the sequence to let the parser infer the whole sequence. For example `y2,y4,.,y10` is a short version of y2,y4,y6,y8,y10, and `y11,y12,...,y112` is the short version of y11,y12,y13,y14,y15,y16,y17,y18,y19,y110,y111,y112, and `y1a,y2b,...,y5e` is the short version of y1a,y2b,y3c,y4d,y5e.

To ensure that the parser understood you well, you can print the digested syntax with `syntax(model)`. In the case of using ellipsis in the syntax, you can use the same convention to name the parameters,

::: {#exm-ellipsis2}
## Labeling parameters using ellipsis

    model<-'at  =~ lambda1*a1 + ... + lambda5*a5'
:::

In @exm-ellipsis2 a latent variable is defined using five indicators a1, a2, a3, a4, a5 with corresponding factor loadings lambda1, lambda2, lambda3, lambda4, lambda5.

### Alias

Aliases are convenient for defining short and long version of variable and parameter names to have a concise code and clear outputs. It happens that you want to use the short version of a variable or parameter to have a more concise code, and you want to print the full name in the outputs. To do this you can define variable aliases with keyword `as` like

    dp as depression

Consequently you can use *dp* and *depression* interchangeably in the code, while by convenient the right hand side of `as` keyword is displayed in the outputs. You can use aliases for any latent or observed variable or any parameter you define in the model. You can merge aliases in to a single line to define aliases for a set of variables or parameters at once, proviso that the length of sequence on the left and right side are the same, some examples are

    p1, p2, p3 as MathScore, PhysicsScore, ChemistryScore
    a1, ..., a9 as StudentAttitude1, ..., StudentAttitude9

When defining aliases you are free to use any character including space on the right hand side of `as` keyword, however if you use special characters or strings such space, `,`, `+` or `=~` then you can not use the alias on the right hand side in the family, regression or measurement blocks. Variable and parameter aliases can also be defined in the `gmlSEM` function by passing an *alias* argument to the function:

    gmlSEM<-gmlSEM(..., alias=c("p"="depression"))

### Random terms

In gmlSEM you can use random terms in the regression models, as you do it in `lme4::lmer`. In the following example we use a random intercept to define a variance component factor model for attitude in `gmlSEM::AttitudeData`.

::: {#exm-exam01}
## Variance-component factor model

    library(gmlSEM)

    model<-'at as attitude

            at =~ a1 + ... + a5
            at = 0 + (1|class)'
              
    gmlSEM<-gmlSEM(model,AttitudeData)
:::

::: callout-note
## Intercept in regression models:

You can explicitly include or exclude intercept in the regression models by adding one of the values -1\|0\|1 to the model. By default, in *gmlSEM* the regression models in which the response is a latent variable does not have an intercept while a regression model in which the response is an observed variable includes an intercept. Thus the '0' in the regression model in previous example is redundant and is considered by default in *gmlSEM*.
:::

You can use assigned names to the random terms to use it as a response or covariate term in other regression models. in *gmlSEM*, you can use the name specifier operator `[as .]` to name any random term in the regression model as in the following example. Consider that you can use name specifier operator `[as .]` only after random terms in the regression models.

::: {#exm-exam1}
## Variance-component factor model

    library(gmlSEM)

    model<-'at as attitude
            
            at =~ a1 + ... + a5
            at = 0 + (1[as c.t]|class)'
              
    gmlSEM<-gmlSEM(model,AttitudeData)
:::

In the previous example we use the suffix operator `[as .]` to assign the name 'c.t' to the random intercept. If you do not assign name to the random terms, *gmlSEM* automatically assign names to the random terms by convention with the template *response.level.covariate*. For example in `at = 0 + (1 + x |class)`, the *gmlSEM* assign names `at.class.1` and `at.class.x` by convention to the random intercept and random slop terms, respectively.

As in *lavaan*, in measurement and regression models you can assign parameter labels to the parameters of the model using pre-multiplication mechanism (using `*` operator). In a regression model, pre-multiplication mechanism assign parameter labels to either regression coefficient or random term's standard deviation, depending it is a fixed term or random term. Thus in the following example `beta` refers to the regression coefficient of the fixed term `x`, and `c.t.std` refers to the standard deviation of the random intercept term in the model.

::: {#exm-exam02}
## Variance-component factor model

    library(gmlSEM)

    model<-'at as attitude
              
            at =~ a1 + ... + a5
            at = 0 + beta * x + (c.t.std * 1[as c.t]|class)'
              
    gmlSEM<-gmlSEM(model,AttitudeData)
:::

### Level

In a Mult-Level SEM, for the data is assumed a hierarchy structure. The observed and latent variables vary at different levels. In *gmlSEM* you can use the `level:` block to specify the levels and nested levels and use the phrase `vary at level` or its variant `varies at level` to specify which latent or observed variable vary at which level if necessary. In a Multi-Level model at *gmlSEM*, we use 'record' and 'elementary unit' interchangeably to refer to the units at the lowest level. The data can be provided in *gmlSEM* with one or more data frame. When the *gmlSEM* is provided by a data frame, an elementary unit is simply a row in the data frame. When multiple data frames feed to *gmlSEM*, an elementary unit is a row in the data frame representing data at the lowest level.

Considering simulated dataset `gmlSEM::AttitudeData`. Students attitude is recorded in variables a1, ..., a5 and the performance of students in three major courses are recorded as p1, p2, p3. Subjects are clustered in classes and schools, and the school id and class id for each subject are specified in variables *school* and *class*. In *gmlSEM*, to define a multi-level factor model, we can use one or more `level:` blocks to specify the levels,

::: {#exm-lev1}
## Factor model with two levels

    level: school
    s.a as school climate

    s.a varies at level school

    s.a =~ a1 + ... + a5
:::

In @exm-lev1 a factor model with two levels is defined. The first level is 'base' level encompasses elementary units, and the second level is defined by variable school with `level: school`. The latent variable s.a as 'school climate' is defined that varies at the second level.

The next model, defines three factor models in a three level model.

::: {#exm-lev2}
## Factor model with three levels

    level: school
    level: class within school

    s.a as school climate
    s.p as school performance
    c.p as class performance

    s.p,s.a vary at level school
    c.p     varies at level class

    s.a     =~ a1 + ... + a5
    s.p,c.p =~ p1 + ... + p5
:::

In @exm-lev2 the second level is class nested within school as the third level. Both 2^nd^ and 3^rd^ level and their nested structure is understood in the second line, and hence the first line is redundant. The model will remain unchanged if you omit the first line.

For models with higher number of levels, you can use multiple `within` keyword in a single `level:` command to specify the nested structure of the levels.

Combining random effects in SEM make the models more flexible and easy to write and interpret in some scenarios. To see an example, we will rewrite an equivalent form of the variance-component factor model in @exm-exam1 in terms of a two-level factor model. That is to define two latent variables with the same factor model, one varies at the base level and the other one varies at the level class named 'class climate', with a constraint that factor loadings are equal in both factor models.

::: {#exm-exam2}
## Variance-component factor model-hard syntax

    model<-'level: class
            at as attitude
            c.c as class climate
              
            c.c varies at level class
              
            at  =~ lambda1*a1 + ... + lambda5*a5
            c.c =~ lambda1*a1 + ... + lambda5*a5
            
            lambda1==1'
:::

In @exm-exam2 a level is defined and a latent variable 'c.c' as 'class climate' which varies at this level. Two latent factors 'attitude' and 'class climate' are defined with a constraint that factor loadings are equal in both factor model, while attitude varies at the 'base' level and 'class climate' varies at level 'class'. The two factor models could also be combined into a single line as

            c.c,at=~lambda1*a1 + ... + lambda5*a5

::: callout-note
## Specifying the levels at which variables vary:

It is a good practice to use `vary at level` phrase and explicitly list all *latent variables and observed response variables* that vary at the second level or higher, though it is not always necessary. If the level at which an observed response variable or a latent variable varies is not specified in the model, *gmlSEM* will infer it from data and model.

Concerning the observed response variables, *gmlSEM* will scan the variable and will identify the level at which the given variable varies, and concerning the latent variables, *gmlSEM* infers the level from the measurement models. If the level is not specified for a latent variable, *gmlSEM* will produce a warning and will consider the lowest level at which all the indicator variables vary at that level or a lower sublevel. You can see a report from the multi-level structure of the model by `levels(model)`. See `?gmlSEM::levels` to learn more.

There is no need to list the variables vary at the '*base*' level, however you can do it by

    y varies at level 1
:::

:::{.callout-important}

In a Multi-Level model in *gmlSEM*, you have to note that

-   In a regression model, the response variable must vary at the same level or a lower level than the covariates.

-   In a measurement model, the latent variable must vary at the same level or a higher level than the indicators.

:::

::: callout-note
## Order of lines:

The order of lines in *gmlSEM* syntax does not matter. So @exm-exam2 can also be reordered to get easier to read as

    model<-'level: class

            at as attitude
            at  =~ lambda1*a1 + ... + lambda5*a5
            
            c.c as class climate
            c.c varies at level class
            c.c =~ lambda1*a1 + ... + lambda5*a5
            
            lambda1==1'
:::

::: callout-note
## Identifiability of models:

In factor models you have to take care of identifiablity by putting a constraint on the factor loadings or the variance of latent variable. If you did not specify the necessary constraint, *gmlSEM* will set the first factor loading to one by default. You can ether set the variance to one by

    at ~~ 1*at

or set a factor loading by pre-multiplication mechanism like

    at =~ a1 + 1*a2 + a3 + a4 + a5
:::

### Family

In *gmlSEM* you can define the distribution of endogenous observe or latent variables in a `family:` command. In the following example we define a factor model with zero-inflated beta distribution for indicators. You can use many other distributions in *gmlSEM*. See `?gmlSEM::family` to learn more about different distributions that is provided in the package. You can also define your own distribution to use in *gmlSEM*.

In the following two examples you can see how we can use the family: block to fit a probit regression model and a factor model with zero-inflated beta indicators:

::: {#exm-fam5}
## A probit regression model

    model<-'family: y binomial(link="probit")
            y = x1 + x2'
:::

::: {#exm-fam1}
## Factor model with zero-inflated beta indicators

    model<-'family: y1, y2, ..., y5 zoib(link=c("probit","logit"),type="[0,1]")
              eta =~ y1 + ... + y5'
:::

When defining the family of distribution for a set of variables, you can also take advantage of copula functions to induce the conditional dependency between endogenous observed or latent variables:

::: {#exm-fam2}
## Using copula to induce conditional dependency in factor models

    model1<-'family: y1, y2, ..., y5  binomial(link="probit") copula(type="gaussian")
              eta =~ y1 + ... + y5'
              
    model2<-'family: 
              y1, ..., y5 binomial(link="probit") copula(type="gaussian")
             family: eta1, eta2 gamma(lin="log") copula(type="gaussian")
             eta =~ y1 + ... + y5'
:::

Introducing a copula term in the `family:` command lead to multivariate conditional dependency between the variables in that command provided that they varying at the same level. If the variables vary at different levels, a warning is produced and each set of variables varying at the same level will consider to be conditionally dependent using the introduced copula. For example in the following model, the set of `y1,...,y5` are conditionally dependent according to the Gaussian copula at level class, and `y6,...,y10` are conditionally dependent according to the Gaussian copula at level school.

::: {#exm-fam3}
## Using copula to induce conditional dependency in a multi-level factor model

    model<-'level:  class within school
             y1, ..., y5  vary at level class
             y6, ...,y10 vary at level school
             
             family: y1, y2, ..., y10 binomial(link="probit") copula(type="gaussian")
             
             eta1 =~ y1 + ... + y5
             eta2 =~ y6 + ... + y10'
:::

In the @exm-fam3, *eta1* is a latent variable vary at level *class*, and *eta2* is a latent variable vary at level *school*. Adding a `family:` command with copula for defining the family of distribution for these two variable producing a warning and gmlSEM simply ignore the copula structure:

<div>

    model<-'level: class within school
             y1, ..., y5  vary between classes
             y6, ..., y10 vary between schools
             
             family: y1, y2, ..., y10 binomial(link="probit") copula(type="gaussian")
             family: eta1, eta2 gamma(link="log") copula(type="gaussian")
             
             eta1 =~ y1 + ... + y5
             eta2 =~ y6 + ... + y10'

</div>

You can also use copula functions to induce conditional dependency between different family of distributions by introducing the copula in a separate `family:` command as follow:

::: {#exm-fam4}
## Conditional dependency between variables with different distributions:

    model<-'family: y1, ..., y5  binomial(link="probit")
            family: y6, ..., y10 beta(link="logit")
            family: y1, ..., y10 copula(type="gaussian")
             
            eta1 =~ y1 + ... + y5
            eta2 =~ y6 + ... + y10'
:::

::: callout-note
A Gaussian family with identity link function accompanied by a Gaussian copula is equivalent to the multivariate normal distribution for the set of variables. When a Gaussian cupula is added in the `family:` command, all pairwise conditional covariances are free to estimate unless you use `~~` operator to set some parameters to zero like:

    model<-'family: y1, y2, ..., y5 binomial(link="logit") copula(type="gaussian")
             
             eta1 =~ y1 + ... + y5
             y1 ~~ 0*y2'

You can also set the free parameters to zero by default in the copula term, and use the \~\~ operator to specify those conditional covariances to be estimated

    model<-'family: y1, y2, ..., y5 binomial(link="logit") copula(type="gaussian",covariance=0)
             
             eta1 =~ y1 + ... + y5
             y1 ~~ y2+...+y5'

A binomial family accompanied with a Gaussian copula will result in another good modification to the model. See `?gmlSEM::copula` to learn more.
:::
